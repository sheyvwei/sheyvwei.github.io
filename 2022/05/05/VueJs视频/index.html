<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>Vue教学视频 | Hexo</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><meta name="generator" content="Hexo 5.4.2"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Vue教学视频</h1><a id="logo" href="/.">Hexo</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Vue教学视频</h1><div class="post-meta">2022-05-05</div><div class="post-content"><h1 id="VueJs视频"><a href="#VueJs视频" class="headerlink" title="VueJs视频"></a>VueJs视频</h1><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Zy4y1K7SH?p=2">参考链接</a></p>
<h2 id="P2"><a href="#P2" class="headerlink" title="P2"></a>P2</h2><p>VueJs是一个用于构建用户界面的渐进式JavaScript框架</p>
<p>什么是渐进式？<br>特点？<br>1、组件化：复用，更好维护<br>2、采用声明式编码    和命令式编码的区别？<br>3、使用虚拟DOM和Diff算法     与原来的Real-Dom拼接html</p>
<h2 id="P3"><a href="#P3" class="headerlink" title="P3"></a>P3</h2><p>介绍 vuejs官网</p>
<h2 id="P4"><a href="#P4" class="headerlink" title="P4"></a>P4</h2><p>1、开发版和生产环境版本<br>2、搭建环境–视频采用直接引用js包进行引用</p>
<h2 id="P5-让Vue开始工作"><a href="#P5-让Vue开始工作" class="headerlink" title="P5 让Vue开始工作"></a>P5 让Vue开始工作</h2><p>1、html创建容器，一般在div中设置id=”root”<br>2、再创建Vue实例，设置el和data： el用来关联哪个容器，data设置数据</p>
<p>3、通过插值来将data的数据放入容器中，容器即Vue模板，将插值全部替换成data中的数据</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">	<span class="attr">el</span>: <span class="string">&#x27;root&#x27;</span>, <span class="comment">// el 为element元素的缩写</span></span><br><span class="line">	<span class="attr">data</span>: &#123;</span><br><span class="line">		<span class="attr">name</span>: <span class="string">&#x27;名字&#x27;</span>,</span><br><span class="line">		<span class="attr">age</span>: <span class="string">&#x27;25&#x27;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="P6"><a href="#P6" class="headerlink" title="P6"></a>P6</h2><p>1、一个实例只能对应一个容器</p>
<p>2、开发环境使用的vue.js和生产版本引用的vue.min.js</p>
<h2 id="P7、模板语法"><a href="#P7、模板语法" class="headerlink" title="P7、模板语法"></a>P7、模板语法</h2><p>1、插值语法。 用于标签体内容<br>2、指令语法  用于标签，包含标签体内容，标签属性，绑定事件<br>3、学习了v-bind指令语法，只要用于使标签属性内容变成js表达式，v-bind:href缩写 :href</p>
<h2 id="P8-数据绑定-专门绑定标签的value值"><a href="#P8-数据绑定-专门绑定标签的value值" class="headerlink" title="P8  数据绑定  专门绑定标签的value值"></a>P8  数据绑定  专门绑定标签的value值</h2><p>1、单向数据绑定 v-bind:value=””, 可以缩写 :value=””<br>2、双向数据绑定 v-model:value<br>3、v-model一般用于表单标签，例如input，select有value属性的标签，用于双向数据绑定。<br>4、因为v-model都是绑定value属性，所以v-model:value=””可以缩写成v-model=””</p>
<h2 id="P9-el和data的两种写法"><a href="#P9-el和data的两种写法" class="headerlink" title="P9 el和data的两种写法"></a>P9 el和data的两种写法</h2><p>1、el的两种写法 ：</p>
<p>（1）在Vue实例对象中指定 el: ‘#root’<br>（2）先创建Vue实例对象，然后通过$mount(‘#root’)进行挂载</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    //方法一</span><br><span class="line">    new Vue(&#123;</span><br><span class="line">        el: &#x27;#root&#x27;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            name: &#x27;名字&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    //方法二  </span><br><span class="line">    const vm = new Vue(&#123;</span><br><span class="line">        data: &#123;</span><br><span class="line">        name: &#x27;名字&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">	vm.$mount(&#x27;#root&#x27;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>2、data的两种写法：</p>
<p>（1）直接申明data为对象</p>
<p>（2）data为一个函数，返回一个对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    //方法一</span><br><span class="line">     data: &#123;</span><br><span class="line">        name: &#x27;名字&#x27;,</span><br><span class="line">        age: &#x27;25&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">    //方法二：</span><br><span class="line">     data: function()&#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            name: &#x27;名字&#x27;,</span><br><span class="line">            age: &#x27;25&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //上面可以缩写成下面的，但是不能缩写成箭头函数，因为作用域变化了</span><br><span class="line">    data()&#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            name: &#x27;名字&#x27;,</span><br><span class="line">            age: &#x27;25&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h2 id="P10-理解MVVM"><a href="#P10-理解MVVM" class="headerlink" title="P10 理解MVVM"></a>P10 理解MVVM</h2><p>VM:viewModel，Vue实例</p>
<h2 id="P11-了解Object-defineProperty-方法"><a href="#P11-了解Object-defineProperty-方法" class="headerlink" title="P11 了解Object.defineProperty()方法"></a>P11 了解Object.defineProperty()方法</h2><p>Object.defineProperty()为对象定义的属性，默认不可枚举，不可直接删除，不可直接修改，但是可以定义getter和setter来进行自定义修改</p>
<h2 id="P12-数据代理"><a href="#P12-数据代理" class="headerlink" title="P12 数据代理"></a>P12 数据代理</h2><p>1、什么是数据代理？</p>
<p>2、怎么操作？</p>
<h2 id="P13-Vue中的数据代理运用"><a href="#P13-Vue中的数据代理运用" class="headerlink" title="P13 Vue中的数据代理运用"></a>P13 Vue中的数据代理运用</h2><h2 id="P14-事件处理"><a href="#P14-事件处理" class="headerlink" title="P14 事件处理"></a>P14 事件处理</h2><p>@click</p>
<h2 id="P15事件修饰符"><a href="#P15事件修饰符" class="headerlink" title="P15事件修饰符"></a>P15事件修饰符</h2><p>1、prevent</p>
<p>2、stop</p>
<p>3、once</p>
<p>4、capture</p>
<p>5、self :</p>
<p>6、passive   (移动端或者平板用的比较多)</p>
<p>事件冒泡？</p>
<p>捕获阶段与冒泡阶段？</p>
<h2 id="P16键盘事件"><a href="#P16键盘事件" class="headerlink" title="P16键盘事件"></a>P16键盘事件</h2><h2 id="p17总结事件"><a href="#p17总结事件" class="headerlink" title="p17总结事件"></a>p17总结事件</h2><p>事件处理：v-on或者使用@字符</p>
<p>事件修饰符: prevent， stop， once</p>
<p>键盘事件 @click.enter 按回车触发   @click.keyCodes</p>
<h1 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h1><h2 id="P18-姓名案例"><a href="#P18-姓名案例" class="headerlink" title="P18  姓名案例"></a>P18  姓名案例</h2><p>1、为什么要用到计算属性？</p>
<p>2、主要讲解不用计算属性时，直接用模板或者函数实现需求</p>
<h2 id="P19-计算属性"><a href="#P19-计算属性" class="headerlink" title="P19 计算属性"></a>P19 计算属性</h2><p>1、怎么使用？</p>
<p>2、与methods？ 优点？</p>
<h2 id="P20-计算属性的简写"><a href="#P20-计算属性的简写" class="headerlink" title="P20 计算属性的简写"></a>P20 计算属性的简写</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">       <span class="comment">//初始</span></span><br><span class="line">       <span class="attr">fullName</span>: &#123;</span><br><span class="line">           <span class="title function_">get</span>(<span class="params"></span>)&#123;</span><br><span class="line">               </span><br><span class="line">           &#125;,</span><br><span class="line">           <span class="title function_">set</span>(<span class="params">value</span>)&#123;</span><br><span class="line">               </span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//简写: 确定只有读的功能，就去掉setter</span></span><br><span class="line">       <span class="attr">fullName</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">           </span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//下面是进一步简写，</span></span><br><span class="line">       <span class="comment">//但是并不表示使用该计算属性的时，就是用 &#123;&#123;fullName()&#125;&#125;, 而是vue实例中：fullName = fullName()函数</span></span><br><span class="line">       <span class="title function_">fullName</span>(<span class="params"></span>)&#123;</span><br><span class="line">           </span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h1 id="监视属性"><a href="#监视属性" class="headerlink" title="监视属性"></a>监视属性</h1><h2 id="P21-监视属性"><a href="#P21-监视属性" class="headerlink" title="P21 监视属性"></a>P21 监视属性</h2><p>1、主要将不用监视属性怎么操作</p>
<h2 id="P22-使用监视属性"><a href="#P22-使用监视属性" class="headerlink" title="P22 使用监视属性"></a>P22 使用监视属性</h2><p>1、两种写法： （1） Vue中使用 watch配置，（2）通过 vm.$watch(‘attr’,{……}) 配置</p>
<p>2、可以监听哪些数据    （1）data中的    （2） 计算属性computed中的</p>
<h2 id="P23深度监视"><a href="#P23深度监视" class="headerlink" title="P23深度监视"></a>P23深度监视</h2><p>1、什么是深度监视？ 监视对象中的某些值</p>
<p>2、什么时候需要？</p>
<h2 id="P24-深度监视的简写"><a href="#P24-深度监视的简写" class="headerlink" title="P24 深度监视的简写"></a>P24 深度监视的简写</h2><p>两种方式写监视属性的简写分别是什么？</p>
<h2 id="25-计算属性和监视属性的对比"><a href="#25-计算属性和监视属性的对比" class="headerlink" title="25 计算属性和监视属性的对比"></a>25 计算属性和监视属性的对比</h2><p>什么时候用计算属性，什么时候用监视属性</p>
<h2 id="26-绑定class样式"><a href="#26-绑定class样式" class="headerlink" title="26 绑定class样式"></a>26 绑定class样式</h2><p>三种情况绑定class样式 （1）字符串，（2）数组，（3）对象</p>
<h2 id="27-绑定style样式"><a href="#27-绑定style样式" class="headerlink" title="27 绑定style样式"></a>27 绑定style样式</h2><p>两种方式绑定样式  1、数组，2 、对象</p>
<h2 id="P28-条件渲染"><a href="#P28-条件渲染" class="headerlink" title="P28 条件渲染"></a>P28 条件渲染</h2><p>1、v-show?</p>
<p>2、v-if ？</p>
<p>3、v-show和v-if的区别，什么时候用哪个比较好</p>
<p>4、v-if ， v-else-if和v-else 使用要连续， </p>
<p>5、template的使用？  只配合v-if，不能与v-show使用</p>
<h1 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h1><h2 id="P29-列表渲染"><a href="#P29-列表渲染" class="headerlink" title="P29 列表渲染"></a>P29 列表渲染</h2><p>1、学习v-for，使用v-for遍历数组，对象，字符串或指定次数，其中数组对象用的比较多</p>
<p>2、使用v-for = “ (item,index) in arr”  进行遍历，</p>
<h2 id="P30-key的作用和原理"><a href="#P30-key的作用和原理" class="headerlink" title="P30 key的作用和原理"></a>P30 key的作用和原理</h2><p>1、为什么都要配置一个key？</p>
<p>2、为什么用index作为key时效率低？</p>
<p>3、为什么不用key时，或者key的值为index的时候，动态添加input时出错？：key的工作原理及虚拟Dom的对比算法，【新虚拟dom】与【旧虚拟dom】对比，它们对比是通过key值相同进行对比的，【有变化的虚拟dom】直接转化为真实dom，【没变化的虚拟dom】复用旧dom已经转化的真实dom</p>
<p>4、什么时候index错乱？不按照顺序，有输入类框</p>
<h2 id="P31-列表过滤"><a href="#P31-列表过滤" class="headerlink" title="P31 列表过滤"></a>P31 列表过滤</h2><h2 id="P32列表排序"><a href="#P32列表排序" class="headerlink" title="P32列表排序"></a>P32列表排序</h2><h1 id="vue监测数据改变的原理"><a href="#vue监测数据改变的原理" class="headerlink" title="vue监测数据改变的原理"></a>vue监测数据改变的原理</h1><h2 id="P33-监测异常描述"><a href="#P33-监测异常描述" class="headerlink" title="P33 监测异常描述"></a>P33 监测异常描述</h2><h2 id="P34-监测原理-对象"><a href="#P34-监测原理-对象" class="headerlink" title="P34 监测原理(对象)"></a>P34 监测原理(对象)</h2><p>监测对象的改变，写一个类似Vue的Observe函数，进行监测数据的改变</p>
<h2 id="P35-Vue-set-的使用"><a href="#P35-Vue-set-的使用" class="headerlink" title="P35 Vue.set()的使用"></a>P35 Vue.set()的使用</h2><p>1、后天自己添加响应式的属性，可以通过Vue.set(target,key,value)或者vm.$set()进行设置,但是这个属性不能直接是vm或者vm中的data，需要时vm.data中的对象.</p>
<p>2、通过上面的两个方法，可以后面动态加载响应式属性</p>
<h2 id="P36-监测数据类型为数组的改变"><a href="#P36-监测数据类型为数组的改变" class="headerlink" title="P36 监测数据类型为数组的改变"></a>P36 监测数据类型为数组的改变</h2><p>1、vue中通过赋值进行数据的改变不会触发页面的改变，因为vue没有给某个具体值设置getter和setter方法，</p>
<p>2、vue是通过检测数组的push，pop，sort，splice等数组的方法，然后进行生成虚拟dom，与真实dom对比，在进行更改页面</p>
<p>3、如果数组不使用上面的数组包装方法，也可以通过Vue.set()或者vm.$set()进行响应式编程</p>
<h2 id="P37Vue监视数据总结"><a href="#P37Vue监视数据总结" class="headerlink" title="P37Vue监视数据总结"></a>P37Vue监视数据总结</h2><p>Vue.set()或者vm.$set()进行数据变更时，它不能对data根数据进行添加</p>
<h2 id="P38-收集表单数据"><a href="#P38-收集表单数据" class="headerlink" title="P38 收集表单数据"></a>P38 收集表单数据</h2><p>1、v-mode双向绑定value值，所以记得提供，</p>
<p>2、当input为多个checkbox时，记得给v-model的变量申明为数组，除非只有一个ckeckbox时，你要绑定checked的true或false值</p>
<p>3、v-model中的修饰符有哪些？ lazy,number,trim</p>
<h2 id="P39过滤器（格式化数据）"><a href="#P39过滤器（格式化数据）" class="headerlink" title="P39过滤器（格式化数据）"></a>P39过滤器（格式化数据）</h2><p>1、作用？</p>
<p>2、用法 ？ 管道符</p>
<p>3、可以用在哪里？    插值语法 或者   v-on:x=”msg | formatTime”</p>
<p>4、局部过滤器和全局过滤器的申请？ filters：   Vue.filter(‘name’, function(){})</p>
<h1 id="Vue中的指令"><a href="#Vue中的指令" class="headerlink" title="Vue中的指令"></a>Vue中的指令</h1><h2 id="P40-v-text"><a href="#P40-v-text" class="headerlink" title="P40 v-text"></a>P40 v-text</h2><h2 id="P41-v-html"><a href="#P41-v-html" class="headerlink" title="P41 v-html"></a>P41 v-html</h2><p>1、v-html与v-text的区别</p>
<p>2、可能引发的问题？安全性问题 （动态加载html标签会引起xss攻击）</p>
<h2 id="P42-v-cloak"><a href="#P42-v-cloak" class="headerlink" title="P42 v-cloak"></a>P42 v-cloak</h2><p>1、作用？ 避免当js出现堵塞时，模板直接出现在客户页面中</p>
<p>2、使用？ v-cloak标记在标签中，在配合css的display:none中</p>
<h2 id="P43-v-once"><a href="#P43-v-once" class="headerlink" title="P43 v-once"></a>P43 v-once</h2><p>1、注意和事件修饰符的once区别</p>
<h2 id="p44-v-pre"><a href="#p44-v-pre" class="headerlink" title="p44 v-pre"></a>p44 v-pre</h2><p>1、让vue跳过该标签或者模板，加快解析，后台写什么，它就会在前端显示什么，不会让vue起作用</p>
<h1 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h1><h2 id="P45-自定义指令"><a href="#P45-自定义指令" class="headerlink" title="P45 自定义指令"></a>P45 自定义指令</h2><p>1、用法？（函数，或者对象）</p>
<p>  big(element, binding)(){}    两个参数，第一个参数值为指令所在标签，第二个参数为绑定的值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">v-big = <span class="string">&quot;n&quot;</span></span><br><span class="line"><span class="attr">directives</span>: &#123;</span><br><span class="line">                <span class="title function_">big</span>(<span class="params">element,binding</span>)&#123;</span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(element, binding)</span><br><span class="line">                    element.<span class="property">innerText</span> = binding.<span class="property">value</span> * <span class="number">5</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>



<h2 id="P46-通过对象自定义指令"><a href="#P46-通过对象自定义指令" class="headerlink" title="P46 通过对象自定义指令"></a>P46 通过对象自定义指令</h2><p>通过对象自定义属性虽然麻烦，但是可以避免当自定义指令所在的标签插入到页面的时候，用到该标签的父元素或者获取焦点的时候</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">directives</span>: &#123;</span><br><span class="line">    <span class="attr">fbind</span>: &#123;</span><br><span class="line">        <span class="comment">//(1)指令内容与元素进行绑定，</span></span><br><span class="line">        <span class="comment">//（2）然后插入到页面中。</span></span><br><span class="line">        <span class="comment">//（3) 当页面模板又有更新数据时，重新解析模板。</span></span><br><span class="line">        <span class="title function_">bind</span>(<span class="params">element, binding</span>)&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">inserted</span>(<span class="params">element, binding</span>)&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">update</span>(<span class="params">element, binding</span>)&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P47-自定义指令总结"><a href="#P47-自定义指令总结" class="headerlink" title="P47 自定义指令总结"></a>P47 自定义指令总结</h2><p>1、定义？ 像过滤器一样，有全局定义和局部定义</p>
<p>2、完整写法和简写？</p>
<p>3、命名方法推荐 kebab-case命名方式，不要用camelCase命名</p>
<h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><h2 id="P48引入生命周期函数"><a href="#P48引入生命周期函数" class="headerlink" title="P48引入生命周期函数"></a>P48引入生命周期函数</h2><p>1、是一个特殊的函数，不可重命名</p>
<p>2、认识第一个生命周期函数mounted(), 它什么时候调用？ vue将虚拟dom转化为真实dom，并将它挂载到页面的时候</p>
<h2 id="49-分析生命周期函数的挂载阶段"><a href="#49-分析生命周期函数的挂载阶段" class="headerlink" title="49 分析生命周期函数的挂载阶段"></a>49 分析生命周期函数的挂载阶段</h2><p>1、可以通过增加debugger;语句进行调试</p>
<p>2、初始化vue的生命周期，事件 -&gt;   beforeCreate() -&gt; 初始化数据监测，数据代理 -&gt; created() -&gt;  解析dom -&gt;  beforeMount()  -&gt; vm.$el = el(创建真实dom ) -&gt; mounted() </p>
<p>3、直接在#root写dom标签与在vue中使用template写标签的区别？ 它们的范围不同</p>
<h2 id="50-分析生命周期的更新阶段"><a href="#50-分析生命周期的更新阶段" class="headerlink" title="50 分析生命周期的更新阶段"></a>50 分析生命周期的更新阶段</h2><p>1、 data update -&gt; beforeUpdate()（数据是新的，页面是旧的) -&gt;   新的虚拟dom与旧的虚拟dom进行比较，最后更新到真实dom -&gt; updated() </p>
<h2 id="51-分析生命周期的销毁阶段"><a href="#51-分析生命周期的销毁阶段" class="headerlink" title="51 分析生命周期的销毁阶段"></a>51 分析生命周期的销毁阶段</h2><p>1、 vm.$destroy() -&gt; beforeDestroy()  -&gt;  关闭watch和组件间的联系，事件监听 -&gt; destroyed()</p>
<h2 id="p52-生命周期总结"><a href="#p52-生命周期总结" class="headerlink" title="p52 生命周期总结"></a>p52 生命周期总结</h2><p>1、vm.$destroy一般用在自己销毁，还有在路由或者其他情况也会触发destroy生命周期</p>
<p>2、 常用的钩子： mounted()和beforeDestroy() 这两个函数分别写什么?  </p>
<p>3、mounted函数写发送ajax请求，启动定时器，绑定自定义事件，订阅消息</p>
<p>4、beforeDestroy：清除定时器，解绑自定义事件，取消订阅等</p>
<p>5、不要在beforedestroy中操作数据，即使操作也不会反应到页面上</p>
<p>6、Destroy触发后，vue中的自定义事件会停止，但是原生dom事件依然有效，比如说之前设置一个定时器</p>
<h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><h2 id="p53-组件的理解"><a href="#p53-组件的理解" class="headerlink" title="p53 组件的理解"></a>p53 组件的理解</h2><p>1、什么是组件，为什么要用组件？</p>
<h2 id="P54非单文件组件"><a href="#P54非单文件组件" class="headerlink" title="P54非单文件组件"></a>P54非单文件组件</h2><p>1、使用组件三个步骤  创建组件，注册组件，使用</p>
<p>2、注册组件可以有局部注册和全局注册</p>
<p>3、全局注册组件在其他root的vm中都可以使用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建</span></span><br><span class="line"><span class="keyword">const</span> school = <span class="title class_">Vue</span>.<span class="title function_">extend</span>(&#123;...&#125;)</span><br><span class="line"><span class="comment">//局部注册，在vm实例中使用components</span></span><br><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">	<span class="attr">el</span>: <span class="string">&#x27;#root&#x27;</span>,</span><br><span class="line">	<span class="attr">data</span>:&#123;&#125;,</span><br><span class="line">	<span class="attr">components</span>: &#123;school, studentInfo...&#125;   <span class="comment">/*局部注册组件  */</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 全局注册</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;school&#x27;</span>, school)</span><br></pre></td></tr></table></figure>





<h2 id="p55-组件的几个注意点"><a href="#p55-组件的几个注意点" class="headerlink" title="p55 组件的几个注意点"></a>p55 组件的几个注意点</h2><p>1、组件名称推荐</p>
<p>2、vue组件标签命名定义name，来改变开发者工具的名字</p>
<p>3、非当文件组件中的Vue.extend可以直接申明一个对象的变量也可以，但是vue同样会调用Vue.extend</p>
<h2 id="p56-组件的嵌套"><a href="#p56-组件的嵌套" class="headerlink" title="p56 组件的嵌套"></a>p56 组件的嵌套</h2><h2 id="p57-VueComponent构造函数"><a href="#p57-VueComponent构造函数" class="headerlink" title="p57 VueComponent构造函数"></a>p57 VueComponent构造函数</h2><p>1、组件都是通过Vue.extend()的构造函数创建出来的，每个Vue.extend()都会创建一个新的VueComponent构造函数</p>
<p>2、组件的this都是VueComponent实例对象，new Vue()的this是Vue的实例对象</p>
<p>3、通过Vue.extend创建的组件，其实是一个构造函数，实例对象为通过使用组件后，vue解析页面，会创建组件实例对象</p>
<h2 id="p58-Vue实例和组件实例"><a href="#p58-Vue实例和组件实例" class="headerlink" title="p58 Vue实例和组件实例"></a>p58 Vue实例和组件实例</h2><p>1、Vue和VueComponent类似，但是其区别？  el配置，data可以返回函数也可以返回对象，但是组件中只能返回data</p>
<h2 id="p59一个重要的内置关系"><a href="#p59一个重要的内置关系" class="headerlink" title="p59一个重要的内置关系"></a>p59一个重要的内置关系</h2><p>1、构造函数都有一个prototype属性，指向一个对象，这个属性叫做显示原型属性 ，指向的对象叫做原型对象，</p>
<p>2、通过这个构造函数创建的实例对象，有个__proto__属性，叫做隐式原型属性，它会指向原型对象，来达到继承的作用</p>
<p>3、所以组件实例对象的__proto__属性指向 VueComponent的原型对象，Vue代码又进一步将VueComponent的proto__指向Vue的原型对象</p>
<p>4、VueComponent.prototype._<em>proto</em>_   === Vue.prototype   达到组件最终能访问vue原型上的属性</p>
<h1 id="Vue脚手架"><a href="#Vue脚手架" class="headerlink" title="Vue脚手架"></a>Vue脚手架</h1><h2 id="p60单文件组件"><a href="#p60单文件组件" class="headerlink" title="p60单文件组件"></a>p60单文件组件</h2><p>1、单文件需要放在脚手架里面运行，.vue文件浏览器不会解析，脚手架里有Babel转码器，会将es6转化为es5，浏览器才能解析</p>
<h2 id="p61单文件组件"><a href="#p61单文件组件" class="headerlink" title="p61单文件组件"></a>p61单文件组件</h2><p>1、使用Vue脚手架</p>
<p>(1)、 设置npm的淘宝镜像：  npm config set registry <a target="_blank" rel="noopener" href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a></p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>

<p>(2)、全局安装  @vue/cli（一次安装永久使用,在cmd中使用vue验证） </p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g @vue/cli</span><br></pre></td></tr></table></figure>

<p>(3)、 切换目录，创建你想要的项目</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue create XXX</span><br></pre></td></tr></table></figure>

<p>(4)、cd 启动项目</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run serve</span><br></pre></td></tr></table></figure>





<h2 id="p62-分析脚手架"><a href="#p62-分析脚手架" class="headerlink" title="p62 分析脚手架"></a>p62 分析脚手架</h2><h2 id="p63-分析render函数"><a href="#p63-分析render函数" class="headerlink" title="p63 分析render函数"></a>p63 分析render函数</h2><p>1、为什么需要使用render函数？（缺少模板解析器的vue）</p>
<p>2、为什么引入的是残缺的vue？</p>
<p>3、vue完整包括核心和模板解析器，webpack打包后，模板解析器已经不需要使用，所以vue会分解成好几个成分</p>
<h2 id="P64-修改默认配置"><a href="#P64-修改默认配置" class="headerlink" title="P64 修改默认配置"></a>P64 修改默认配置</h2><p>1、导出vue的配置(只供查看，需要修改则需要配置vue.config.js)： </p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue inspect &gt; output.js</span><br></pre></td></tr></table></figure>

<p>2、怎么自定义修改配置？ 增加vue.config.js，自定义配置</p>
<h2 id="P65-ref属性"><a href="#P65-ref属性" class="headerlink" title="P65 ref属性"></a>P65 ref属性</h2><p>1、类似html标签的id属性，为什么需要ref属性？在子组件标记使用，可以返回子组件的实例对象 </p>
<h2 id="p66-props配置"><a href="#p66-props配置" class="headerlink" title="p66 props配置"></a>p66 props配置</h2><p>1、作用，接受父组件传过来的值，</p>
<p>2、怎么写？</p>
<p>3、三种书写方式？ 数组，key:value， 对象</p>
<p>4、注意点？ props的每个属性只读，如果想在子组件中修改值，需在data创建中间值，data中的数据想改就改</p>
<p>5、设置props的数据类型后，如果设置某个参数为Number，父组件怎么传递值？  通过:age=’number’</p>
<h2 id="p67-mixin混入"><a href="#p67-mixin混入" class="headerlink" title="p67 mixin混入"></a>p67 mixin混入</h2><p>1、为什么要这个？ 两个组件共用一个配置， 复用配置</p>
<p>2、也有全局混入和局部混入</p>
<p>3、局部混入使用方法？ 数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mixin</span>:[name1,name2....]</span><br></pre></td></tr></table></figure>

<p>4、全局混入在哪里写？ main.js</p>
<h2 id="p68-插件"><a href="#p68-插件" class="headerlink" title="p68 插件"></a>p68 插件</h2><p>1、本质是一个install函数，可以接受Vue对象（或者自定义其他参数)，就可以对Vue对象进行各种操作</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">    <span class="title function_">install</span>(<span class="params">Vue,a,b,c</span>)&#123;</span><br><span class="line">        <span class="title class_">Vue</span>.<span class="title function_">filter</span>()</span><br><span class="line">        <span class="title class_">Vue</span>.<span class="title function_">directive</span>()</span><br><span class="line">        <span class="title class_">Vue</span>.<span class="title function_">mixin</span>()</span><br><span class="line">        <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>2、可以写哪些内容？ 可以全局使用的东西：全局过滤器，全局指令，全局混入，在vue对象的原型增加东西</p>
<h2 id="p69-scoped样式"><a href="#p69-scoped样式" class="headerlink" title="p69 scoped样式"></a>p69 scoped样式</h2><p>1、主要避免各个组件的样式互相影响，避免冲突</p>
<h2 id="p70-TodoList案例"><a href="#p70-TodoList案例" class="headerlink" title="p70 TodoList案例"></a>p70 TodoList案例</h2><p>1、目的：学习组件化的编码流程，按照一定的顺序编码</p>
<p>2、javascript的reduce用途：条件统计</p>
<h2 id="78-浏览器本地存储"><a href="#78-浏览器本地存储" class="headerlink" title="78 浏览器本地存储"></a>78 浏览器本地存储</h2><p>1、webStorage浏览器：前端的webstorage有localStorage和sessionStorage</p>
<p>2、localStorage和sessionStorage的区别？</p>
<h2 id="79-TodoList案例使用localStorage"><a href="#79-TodoList案例使用localStorage" class="headerlink" title="79 TodoList案例使用localStorage"></a>79 TodoList案例使用localStorage</h2><p>1、刷新也能保存用户的数据，已完成也能体现出来</p>
<h1 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h1><h2 id="80、组件自定义事件"><a href="#80、组件自定义事件" class="headerlink" title="80、组件自定义事件"></a>80、组件自定义事件</h2><p>this.$emit()</p>
<h2 id="81、组件自定义事件的解绑"><a href="#81、组件自定义事件的解绑" class="headerlink" title="81、组件自定义事件的解绑"></a>81、组件自定义事件的解绑</h2><p>1、this.$off()</p>
<p>2、通过this.$destroy()</p>
<h2 id="82、组件自定义事件总结"><a href="#82、组件自定义事件总结" class="headerlink" title="82、组件自定义事件总结"></a>82、组件自定义事件总结</h2><p>1、通过this.$refs.student.$on触发自定义事件的时候，不同写法的this指向哪里？   <strong>（重要，需要复习）</strong></p>
<p>​    即：通过this.$refs.xxx.$on(‘myClickName’,回调)绑定自定义事件的时候，回调要么配置在methods中，要么用箭头函数，否则this指向有问题， （1、在methods时，回调函数的this作用域在父组件中，2、直接用箭头函数，this的作用与在子组件中，，由于箭头函数会向外部找作用域，所以子组件的外部是父组件，此时的this指向的也是父组件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//复习使用</span></span><br></pre></td></tr></table></figure>



<p>2、组件使用@click原生等事件的时候，默认也是自定义事件，也需要进行敲代码配置，或者使用@click.native </p>
<h2 id="83、todolist案例-增加组件自定义事件"><a href="#83、todolist案例-增加组件自定义事件" class="headerlink" title="83、todolist案例-增加组件自定义事件"></a>83、todolist案例-增加组件自定义事件</h2><h2 id="84、全局事件总线1"><a href="#84、全局事件总线1" class="headerlink" title="84、全局事件总线1"></a>84、全局事件总线1</h2><p>1、作用？ 两组间直接通信</p>
<h2 id="85、全局事件总线2"><a href="#85、全局事件总线2" class="headerlink" title="85、全局事件总线2"></a>85、全局事件总线2</h2><p>1、实质上就是把一个组件放在Vue的原型上， 由于多有app内的组件实例对象在组件内找不到值时，由于原型链的关系，会向外找，找到Vue.prototype上。 为什么是组件放在Vue原型上？   组件才有$on() ， $off()和$emit()</p>
<p>2、一般直接把vm放在Vue的原型上，并赋值在$bus上 </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">	<span class="attr">render</span>: <span class="function"><span class="params">h</span>=&gt;</span><span class="title function_">h</span>(app),</span><br><span class="line">	<span class="title function_">beforeCreated</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$bus</span> = <span class="variable language_">this</span>  <span class="comment">//安装全局事件总线,$bus = vm</span></span><br><span class="line">&#125;).<span class="property">$mount</span>.(app)</span><br></pre></td></tr></table></figure>

<p>3、为什么要放在beforeCreated上？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">	<span class="attr">render</span>: <span class="function"><span class="params">h</span>=&gt;</span><span class="title function_">h</span>(app),</span><br><span class="line">&#125;).<span class="property">$mount</span>.(app)</span><br><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$bus</span> = vm  <span class="comment">//如果是这样赋值在原型上就晚了，app的所有组件页面都已挂载完毕，各个组件通过mounted使用$on获取vm上的东西都不能获取了，所以需要使用beforeCreated</span></span><br></pre></td></tr></table></figure>



<h2 id="86、todolist案例使用事件总线"><a href="#86、todolist案例使用事件总线" class="headerlink" title="86、todolist案例使用事件总线"></a>86、todolist案例使用事件总线</h2><h2 id="87、消息订阅与发布"><a href="#87、消息订阅与发布" class="headerlink" title="87、消息订阅与发布"></a>87、消息订阅与发布</h2><p>1、原生js的这功能比较复杂，视频推荐第三方库，pubsub.js   publish和subscribe</p>
<p>2、订阅与发布，谁需要数据，谁提供数据的区别</p>
<p>3、使用pubsub.js?</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、安装： </span></span><br><span class="line">cmd安装pubsub.<span class="property">js</span>  npm i pubsub-js</span><br><span class="line"><span class="comment">//2、引入： 每个要使用的组件 </span></span><br><span class="line"><span class="keyword">import</span> pubsub <span class="keyword">from</span> pubsub-js</span><br><span class="line"><span class="comment">//3、使用： </span></span><br><span class="line">订阅：pubsub.<span class="property">subscribe</span>     发布：pubsub.<span class="property">publish</span>    取消订阅 pubsub.<span class="title function_">unsubscribe</span>(<span class="title class_">Id</span>)</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">pubId</span> = pubsub.<span class="title function_">subscribe</span>(<span class="string">&#x27;name1&#x27;</span>,<span class="function">(<span class="params">msgName,data</span>)=&gt;</span>&#123;&#125;)</span><br><span class="line"><span class="comment">//4、销毁，和事件总线一样，要记得销毁</span></span><br><span class="line"><span class="title function_">beforeDestroy</span>(<span class="params"></span>)&#123;</span><br><span class="line">	pubsub.<span class="title function_">unsubscribe</span>(pubId)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="88、todolist使用消息订阅与发布"><a href="#88、todolist使用消息订阅与发布" class="headerlink" title="88、todolist使用消息订阅与发布"></a>88、todolist使用消息订阅与发布</h2><h2 id="89、todolist使用编辑"><a href="#89、todolist使用编辑" class="headerlink" title="89、todolist使用编辑"></a>89、todolist使用编辑</h2><p>1、主要是使用 this.$set为某个数据增加属性，只有这样，$set设置的属性有改变，vue就会触发页面更新</p>
<p>2、怎么设置？  this.$set(todo,’isEdit’, true)     （数据，属性，值）</p>
<h2 id="90、-nextTick"><a href="#90、-nextTick" class="headerlink" title="90、 $nextTick"></a>90、 $nextTick</h2><p>1、参数为一个回调函数</p>
<p>2、什么时候执行？ dom节点更新完毕后执行</p>
<p>3、什么时候使用？</p>
<p>4、设置keyup.enter和blur时，同时触发某个函数</p>
<p>如果直接绑定同一个函数，keyup.enter会触发两次函数，因为在按enter键的时候，就会失去焦点，所以触发两次</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;input </span><br><span class="line">    v-show=&quot;todo.isEdit&quot; </span><br><span class="line">    ref=&quot;todoTitle&quot; </span><br><span class="line">    type=&quot;text&quot; </span><br><span class="line">    :value=&quot;todo.title&quot; </span><br><span class="line">    @blur=&quot;saveChange(todo.id,$event)&quot; </span><br><span class="line">    @keyup.enter=&quot;$event.target.blur()&quot;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>





<h2 id="91、动画"><a href="#91、动画" class="headerlink" title="91、动画"></a>91、动画</h2><p>1、使用transition标签</p>
<p>2、设置keyframes     (与过渡的区别就在这里，过渡效果不用写keyframes    ）</p>
<p>3、设置 v-enter-active 以及 v-leave-active</p>
<p>4、让过渡动画马上生效？  appear  或者  :appear=”true”    :表示内容时一个表达式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.hello-enter-active &#123;</span><br><span class="line">	animation: myMove 1s;</span><br><span class="line">&#125;</span><br><span class="line">.hello-leave-active &#123;</span><br><span class="line">	animation: myMove 1s reverse;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@keyframes myMove &#123;</span><br><span class="line">    0%&#123;</span><br><span class="line">        transform: translateX(-100%);</span><br><span class="line">    &#125;</span><br><span class="line">    100%&#123;</span><br><span class="line">        transform: translateX(0px);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="92、过渡"><a href="#92、过渡" class="headerlink" title="92、过渡"></a>92、过渡</h2><p>1、不用写keyframes,</p>
<p>2、<code>来</code> 和 <code>去</code> vue给我们三个类名,其中 字母v可以指定具体name  </p>
<p>3、enter-active可以直接写在具体标签的类名中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    </span><br><span class="line">    /* enter和enter-to的内容其实来自keyframs   就是keyframes的0%和 100%*/</span><br><span class="line">    .v-enter&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    .v-enter-to&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    .v-enter-active&#123;</span><br><span class="line">        transition:  1s linear;    /*这边在动画中是animation*/</span><br><span class="line">    &#125;</span><br><span class="line">    /*   这行可以替换第哦啊enter-active的transition</span><br><span class="line">    .hello&#123;</span><br><span class="line">    	transition: 1s linear;</span><br><span class="line">    &#125;</span><br><span class="line">    */</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>







<h2 id="93、多个元素过渡"><a href="#93、多个元素过渡" class="headerlink" title="93、多个元素过渡"></a>93、多个元素过渡</h2><p>transition-group</p>
<p>1、为什么要有transition-group      transition中只能有包含一个标签，多个标签会报错</p>
<h2 id="94、集成第三方动画库"><a href="#94、集成第三方动画库" class="headerlink" title="94、集成第三方动画库"></a>94、集成第三方动画库</h2><p>1、 npm i animate.css</p>
<p>2、import ‘animate.css’</p>
<p>3、在transition标签的name赋值 ‘animate__animated animate__bounce’</p>
<p>4、给 enter-active-class   和 leave-active-class赋值，赋值内容可以在animate.css复制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;transition </span><br><span class="line">            name=&quot;animate__animated animate__bounce&quot; </span><br><span class="line">            enter-active-class=&quot;animate__backInLeft&quot; </span><br><span class="line">            leave-active-class=&quot;animate__backOutDown&quot;</span><br><span class="line">            appear  </span><br><span class="line">     &gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>



<h2 id="95、总结过渡与动画"><a href="#95、总结过渡与动画" class="headerlink" title="95、总结过渡与动画"></a>95、总结过渡与动画</h2><h2 id="96、配置代理方法一"><a href="#96、配置代理方法一" class="headerlink" title="96、配置代理方法一"></a>96、配置代理方法一</h2><p>1、用什么来解决ajax请求跨域的问题？     axios</p>
<p>2、npm i axios</p>
<p>3、import axios from ‘axios’</p>
<p>4、涉及到跨域请求，达到同源策略即可</p>
<p>5、同源策略:协议名（http)，主机名(localhost)，端口号(8080)</p>
<p>6、为了达到同源策略，可以用代理服务器，cors跨域问题，出现在web’请求时，而有代理服务器后，就不是web请求了，而是http请求</p>
<p>7、代理服务器的实现方法？  方法一：nginx反向代理，方法二：vue-cli</p>
<p>8、怎么用vue-cli开启代理服务器?   写 vue.config.js文件</p>
<p><a target="_blank" rel="noopener" href="https://cli.vuejs.org/zh/config/#devserver-proxy">参考链接</a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在src同级目录中写vue.config.js文件</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">pages</span>: &#123;</span><br><span class="line">        <span class="attr">index</span>: &#123;</span><br><span class="line">            <span class="attr">entry</span>: <span class="string">&#x27;src/main.js&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">lintOnSave</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">devServer</span>: &#123;</span><br><span class="line">        <span class="attr">proxy</span>: <span class="string">&#x27;http://localhost:5000&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="97、配置代理方法二"><a href="#97、配置代理方法二" class="headerlink" title="97、配置代理方法二"></a>97、配置代理方法二</h2><p>用来配置多个代理</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">pages</span>: &#123;</span><br><span class="line">        <span class="attr">index</span>: &#123;</span><br><span class="line">            <span class="attr">entry</span>: <span class="string">&#x27;src/main.js&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">lintOnSave</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">//开启代理服务器方式一</span></span><br><span class="line">    <span class="comment">// devServer: &#123;</span></span><br><span class="line">    <span class="comment">//     proxy: &#x27;http://localhost:5000&#x27;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">//方式二：使用前缀（推荐）</span></span><br><span class="line">    <span class="attr">devServer</span>: &#123;</span><br><span class="line">        <span class="attr">proxy</span>:&#123;</span><br><span class="line">            <span class="string">&#x27;/test&#x27;</span>: &#123;</span><br><span class="line">                <span class="attr">target</span>: <span class="string">&#x27;http://localhost:5000&#x27;</span>,</span><br><span class="line">                <span class="attr">pathRewrite</span>: &#123;<span class="string">&#x27;^/test&#x27;</span>:<span class="string">&#x27;&#x27;</span>&#125;,</span><br><span class="line">                <span class="attr">ws</span>: <span class="literal">true</span>,           <span class="comment">//用于websocket</span></span><br><span class="line">                <span class="attr">changeOrigin</span>: <span class="literal">false</span>  <span class="comment">//改变代理服务器的端口</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&#x27;/demo&#x27;</span>: &#123;</span><br><span class="line">                <span class="attr">target</span>: <span class="string">&#x27;http://localhost:5001&#x27;</span>,</span><br><span class="line">                <span class="attr">pathRewrite</span>:&#123;<span class="string">&#x27;^/demo&#x27;</span>:<span class="string">&#x27;&#x27;</span>&#125;,</span><br><span class="line">                <span class="comment">// ws: true, //用于支持websocket</span></span><br><span class="line">                <span class="comment">// changeOrigin: true //用于控制请求头中的host值</span></span><br><span class="line">              &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="98、Github-搜索案例"><a href="#98、Github-搜索案例" class="headerlink" title="98、Github 搜索案例"></a>98、Github 搜索案例</h2><h2 id="99、"><a href="#99、" class="headerlink" title="99、"></a>99、</h2><h2 id="100、GitHub搜索案例完善"><a href="#100、GitHub搜索案例完善" class="headerlink" title="100、GitHub搜索案例完善"></a>100、GitHub搜索案例完善</h2><p>1、由于isFirst和isLoading和errMsg都是根据search按钮判断出来的，所以，直接通过一个对象传递这些数据即可</p>
<h2 id="101、Resource"><a href="#101、Resource" class="headerlink" title="101、Resource"></a>101、Resource</h2><p>1、是什么？ vue的插件库</p>
<p>2、安装  npm i vue-resource</p>
<p>3、全局安装 Vue.use()</p>
<p>4、使用 this.$http.get(…).then()        类似 axios.get()</p>
<h2 id="102、插槽"><a href="#102、插槽" class="headerlink" title="102、插槽"></a>102、插槽</h2><p>1、 <slot></slot></p>
<p>2、、怎么使用</p>
<h2 id="103、具名插槽"><a href="#103、具名插槽" class="headerlink" title="103、具名插槽"></a>103、具名插槽</h2><p>1、什么时候使用？  当一个组件的里面的插槽有许多的时候，就需要给插槽添加名字</p>
<h2 id="104、作用域插槽"><a href="#104、作用域插槽" class="headerlink" title="104、作用域插槽"></a>104、作用域插槽</h2><p>1、当数据在插槽组件中时，需要把数据传递给使用插槽的组件，可以使用作用域插槽</p>
<h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><h2 id="105、Vuex简介"><a href="#105、Vuex简介" class="headerlink" title="105、Vuex简介"></a>105、Vuex简介</h2><p>1、什么是Vuex，   为vue实现集中数据管理的一个插件</p>
<p>2、什么时候使用？   多组件之前实现共享数据时，全局事件总线虽然能实现兄弟组件的数据传递，但是当多个兄弟组件都用到某个数据的时候，每个组件都需要实现全局实现组件$on()，</p>
<p>3、vuex不属于任意一个组件</p>
<h2 id="106、求和案例-没有使用Vuex"><a href="#106、求和案例-没有使用Vuex" class="headerlink" title="106、求和案例-没有使用Vuex"></a>106、求和案例-没有使用Vuex</h2><h2 id="107、Vuex工作原理"><a href="#107、Vuex工作原理" class="headerlink" title="107、Vuex工作原理"></a>107、Vuex工作原理</h2><img src="F:\Typora\notes\img\vuex.png" alt="vuex" style="zoom:40%;" />





<h2 id="P111-gettters-类似于计算属性"><a href="#P111-gettters-类似于计算属性" class="headerlink" title="P111 gettters 类似于计算属性"></a>P111 gettters 类似于计算属性</h2><h3 id="P124-路由的props"><a href="#P124-路由的props" class="headerlink" title="P124 路由的props"></a>P124 路由的props</h3><p>1、和组件中传递值的区别？</p>
<p>2、怎么写？ 在router/index.js 中写props</p>
<p>3、props写法有几种？   值为对象，  值为 true,   值为函数</p>
<h2 id="p125-router-link的replace属性"><a href="#p125-router-link的replace属性" class="headerlink" title="p125 router-link的replace属性"></a>p125 router-link的replace属性</h2><h2 id="p126-编程式路由导航"><a href="#p126-编程式路由导航" class="headerlink" title="p126 编程式路由导航"></a>p126 编程式路由导航</h2><p>1、直接使用 this.$router访问vuRouter原型链上的方法   this.$router.push , replace, go,  forward, back</p>
<h2 id="p127-缓存路由组件，"><a href="#p127-缓存路由组件，" class="headerlink" title="p127 缓存路由组件，"></a>p127 缓存路由组件，</h2><p>1、某个router-view上的组件切换的时候，该组件是直接被Destroy的，当组件被销毁的时候，用户在组件上输入的内容必定会消失，可以使用 keep-alive 嵌套router-view达到不被销毁的目的。includes可以单独设置要保存的组件名</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--   :include=&quot;[  ...&#x27;name1&#x27;, &#x27;name2&#x27;   ]&quot;   --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span>   <span class="attr">include</span>=<span class="string">&quot;components-name&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="p128-两个新的生命周期钩子"><a href="#p128-两个新的生命周期钩子" class="headerlink" title="p128 两个新的生命周期钩子"></a>p128 两个新的生命周期钩子</h2><p>1、路由组件独有的</p>
<p>2、 activated  deactivated</p>
<p>3、用在什么时候？  当缓存路由组件的时候，希望某个功能停用，而缓存的路由组件destroyed不会被触发，所以写在这两个新的生命周期钩子中，</p>
<p>4、又一个生命周期钩子，  nextTick    当所有的页面渲染完成后触发</p>
<h2 id="p129-全局前置路由守卫"><a href="#p129-全局前置路由守卫" class="headerlink" title="p129 全局前置路由守卫"></a>p129 全局前置路由守卫</h2><p>1、哪里写？  router/index.js写  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = &#123; <span class="attr">routers</span>:: []&#125;  </span><br><span class="line">router.<span class="title function_">beforeEach</span>((o, <span class="keyword">from</span>, next) =&#123;&#125;)</span><br></pre></td></tr></table></figure>

<p>2、  router.beforeEach((o, from, next) ={})</p>
<h2 id="p130-全局后置守卫"><a href="#p130-全局后置守卫" class="headerlink" title="p130 全局后置守卫"></a>p130 全局后置守卫</h2><p>1、 路由有个meta配置项，叫路由元信息，即自定义信息</p>
<p>2、 router.afterEach</p>
<h2 id="p131独享路由守卫"><a href="#p131独享路由守卫" class="headerlink" title="p131独享路由守卫"></a>p131独享路由守卫</h2><p>1、直接在 routers: [] 数组写</p>
<p>beforeEnter: (to, from, next) =&gt;{}</p>
<h2 id="p132-组件中的路由守卫"><a href="#p132-组件中的路由守卫" class="headerlink" title="p132 组件中的路由守卫"></a>p132 组件中的路由守卫</h2><p>1、哪里写， 组件中的js中写</p>
<p>2、写法： </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//进入组件之前调用  ,一定要通过 路由规则进入的时候才会调用</span></span><br><span class="line"><span class="title function_">beforeRouteEnter</span>(<span class="params">to, <span class="keyword">from</span>, next</span>)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 离开组件的时候调用</span></span><br><span class="line">beforeRouteLeave</span><br></pre></td></tr></table></figure>

<p>3、什么时候会触发，通过路由规则进入组件的时候触发</p>
<h2 id="133-history模式和hash模式"><a href="#133-history模式和hash模式" class="headerlink" title="133 history模式和hash模式"></a>133 history模式和hash模式</h2><p>1、存在 # ， 后面的是hash值， hash值（不会作为路径的一部分发送到服务器的值）</p>
<p>2、默认hash模式</p>
<p>3、如何设置  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&#x27;history&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>4、history和hash的差别，     如果使用histroy模式，如何解决刷新页面出现404问题</p>
<h2 id="134-使用UI组件库（eg-element-ui"><a href="#134-使用UI组件库（eg-element-ui" class="headerlink" title="134 使用UI组件库（eg:element-ui)"></a>134 使用UI组件库（eg:element-ui)</h2><p>1、移动端组件库  vant , cube ui , mint ui</p>
<p>2、 element ui , Iview</p>
<h2 id="135-按需引入"><a href="#135-按需引入" class="headerlink" title="135 按需引入"></a>135 按需引入</h2><h2 id="P141-初始setup"><a href="#P141-初始setup" class="headerlink" title="P141 初始setup"></a>P141 初始setup</h2><p>1、常用Composition API （组合式api）</p>
<p>2、什么是setup ？   一个配置项，一个函数</p>
<p>3、setup有两种返回值？  对象， 渲染函数</p>
<h2 id="P142-ref函数"><a href="#P142-ref函数" class="headerlink" title="P142  ref函数"></a>P142  ref函数</h2><p>1、ref函数作用？  实现响应式作用</p>
<h2 id="p144-reactive函数"><a href="#p144-reactive函数" class="headerlink" title="p144 reactive函数"></a>p144 reactive函数</h2><p>1、作用，定义一个对象类型的响应式函数,   reactive将对象转化为proxy实例对象</p>
<p>2、vue3处理响应式 对象 使用proxy，不再使用object.defineproperty</p>
<h2 id="p145-Vue2响应式原理"><a href="#p145-Vue2响应式原理" class="headerlink" title="p145 Vue2响应式原理"></a>p145 Vue2响应式原理</h2><h2 id="p146-Vue3响应式原理"><a href="#p146-Vue3响应式原理" class="headerlink" title="p146 Vue3响应式原理"></a>p146 Vue3响应式原理</h2><h1 id="Vue3"><a href="#Vue3" class="headerlink" title="Vue3"></a>Vue3</h1><h2 id="136-Vue3简介"><a href="#136-Vue3简介" class="headerlink" title="136 Vue3简介"></a>136 Vue3简介</h2><p>1、速度更快，打包更节省空间，</p>
<p>2、源码升级： 使用proxy代替defineProperty实现响应式</p>
<p>3、支持TypeScript</p>
<h2 id="137、使用vue-cli创建vue3工程"><a href="#137、使用vue-cli创建vue3工程" class="headerlink" title="137、使用vue-cli创建vue3工程"></a>137、使用vue-cli创建vue3工程</h2><p>1、vue -V   显示版本为4.5以上的</p>
<h1 id="bootCDN"><a href="#bootCDN" class="headerlink" title="bootCDN"></a><a target="_blank" rel="noopener" href="https://www.bootcdn.cn/">bootCDN</a></h1><p>js脚本下载</p>
<h1 id="Vue中的数据是怎么到页面的？"><a href="#Vue中的数据是怎么到页面的？" class="headerlink" title="Vue中的数据是怎么到页面的？"></a>Vue中的数据是怎么到页面的？</h1><p>data中的数据先通过数据劫持，vm._data = data中的数据，然后通过数据代理，vm._data = vm.data</p>
<h1 id="VsCode中使用用户代码片段提高速度"><a href="#VsCode中使用用户代码片段提高速度" class="headerlink" title="VsCode中使用用户代码片段提高速度"></a>VsCode中使用用户代码片段提高速度</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&quot;Cretae a new Vue&quot;:&#123;</span><br><span class="line">	&quot;scope&quot;: &quot;&quot;,</span><br><span class="line">	&quot;prefix&quot;: &quot;vm&quot;,</span><br><span class="line">	&quot;body&quot;: [</span><br><span class="line">		&quot;&lt;script&gt;&quot;,</span><br><span class="line">		&quot;    var vm = new Vue(&#123;&quot;,</span><br><span class="line">		&quot;        el: &#x27;#root&#x27;,&quot;,     //使用空格缩进，不能使用tab键缩进</span><br><span class="line">		&quot;        data()&#123;&quot;,      //我们也可以使用\t缩进</span><br><span class="line">		&quot;          &quot;,</span><br><span class="line">		&quot;        &#125;&quot;,</span><br><span class="line">		&quot;    &#125;)&quot;,</span><br><span class="line">		&quot;&lt;/script&gt;&quot;,</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="Vue中指令缩写"><a href="#Vue中指令缩写" class="headerlink" title="Vue中指令缩写"></a>Vue中指令缩写</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">	专门绑定标签的value值  </span></span><br><span class="line"><span class="comment">    v-bind   单向绑定， v-model   双向绑定</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">v-<span class="attr">bind</span>:value=<span class="string">&quot;&quot;</span>    =&gt;    :value=<span class="string">&quot;&quot;</span></span><br><span class="line">v-<span class="attr">model</span>:value=<span class="string">&quot;&quot;</span>   =&gt;    v-model=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="comment">/*   </span></span><br><span class="line"><span class="comment">	click事件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">v-<span class="attr">on</span>:click=<span class="string">&quot;&quot;</span>    =&gt;	   @click=<span class="string">&quot;&quot;</span></span><br><span class="line">v-<span class="attr">on</span>:某事件=<span class="string">&quot;&quot;</span>    =&gt;    @某事件=<span class="string">&quot;&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>v-on绑定某个事件，而v-bind:绑定某个数值</p>
<p>v-on的缩写  @     v-bind的缩写 :</p>
<h1 id="使用uuid自动生成id"><a href="#使用uuid自动生成id" class="headerlink" title="使用uuid自动生成id"></a>使用uuid自动生成id</h1><p>1、使用精简的uuid：nanoid</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、安装</span><br><span class="line">npm i nanoid</span><br><span class="line"><span class="number">2</span>、导入, nanoid使用的是分别暴露，所以要&#123;nanoid&#125;, 它是个函数</span><br><span class="line"><span class="keyword">import</span> &#123;nanoid&#125; <span class="keyword">from</span> nanoid</span><br><span class="line"><span class="number">3</span>、使用</span><br><span class="line"><span class="keyword">const</span> pid = <span class="title function_">nanoid</span>()</span><br></pre></td></tr></table></figure>



<h1 id="实现跨域请求"><a href="#实现跨域请求" class="headerlink" title="实现跨域请求"></a>实现跨域请求</h1><p>1、方法一：后端解决cors请求，  怎么做？</p>
<p>2、方法二：前端使用jsonp，后端也要配置使用，  而且只能解决get请求</p>
<p>3、方法三：代理服务器（推荐！！！） </p>
<p>​         前端向后端请求数据，是通过web请求达成目的，web请求涉及到跨域问题，而有代理服务器后，两个服务器之间是不存在跨域问题的，就是单单的http请求</p>
<h1 id="使用静态组件BootStrap"><a href="#使用静态组件BootStrap" class="headerlink" title="使用静态组件BootStrap"></a>使用静态组件BootStrap</h1><p>方法一</p>
<p>1、这边直接下载bootstrap.css</p>
<p>2、在public/index.html中直接通过link导入</p>
<p>方法二：</p>
<p>直接安装bootstrap-vue</p>
</div><div class="tags"></div><div class="post-nav"><a class="next" href="/2022/05/05/Vue%E6%95%99%E5%AD%A6%E8%A7%86%E9%A2%91/">Vue教学视频</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://sheyvwei.github.io"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2022/05/05/VueJs%E8%A7%86%E9%A2%91/">Vue教学视频</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/05/05/Vue%E6%95%99%E5%AD%A6%E8%A7%86%E9%A2%91/">Vue教学视频</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/05/03/hello-world/">Hello World</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Links</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2022 <a href="/." rel="nofollow">Hexo.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="Copy Successed!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>